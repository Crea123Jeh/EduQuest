
// This is an autogenerated file from Firebase Studio.

'use server';

/**
 * @fileOverview A flow for generating dynamic, tailored questions based on student learning history and desired question type.
 *
 * - generateDynamicQuests - A function that generates dynamic questions.
 * - GenerateDynamicQuestsInput - The input type for the generateDynamicQuests function.
 * - GenerateDynamicQuestsOutput - The return type for the generateDynamicQuests function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const QuestionTypeSchema = z.enum([
  'open-ended',
  'multiple-choice',
  'fill-in-the-blank',
]);
export type QuestionType = z.infer<typeof QuestionTypeSchema>;

const GenerateDynamicQuestsInputSchema = z.object({
  studentLearningHistory: z
    .string()
    .describe(
      'The learning history of the student, integrated from Google Classroom, including topics studied, grades, and areas of weakness.'
    ),
  topic: z.string().describe('The topic for which questions need to be generated.'),
  difficultyLevel: z
    .enum(['easy', 'medium', 'hard'])
    .describe('The difficulty level of the questions.'),
  numberOfQuestions: z.number().min(1).max(5).describe('The number of questions to generate (max 5).'),
  questionType: QuestionTypeSchema.describe(
    'The type of questions to generate.'
  ),
});

export type GenerateDynamicQuestsInput = z.infer<
  typeof GenerateDynamicQuestsInputSchema
>;

const OpenEndedQuestionSchema = z.object({
  type: z.literal('open-ended'),
  question: z.string().describe('The open-ended question text.'),
});

const MultipleChoiceQuestionSchema = z.object({
  type: z.literal('multiple-choice'),
  question: z.string().describe('The multiple-choice question text.'),
  options: z
    .array(z.string())
    .min(2)
    .max(5)
    .describe('An array of 2 to 5 answer options.'),
  correctAnswer: z
    .string()
    .describe(
      'The text of the correct answer, which must be one of the provided options.'
    ),
});

const FillInTheBlankQuestionSchema = z.object({
  type: z.literal('fill-in-the-blank'),
  questionWithBlank: z
    .string()
    .describe(
      "The question text with a clear placeholder like '___' or '[BLANK]'. Example: 'The capital of France is ___.'"
    ),
  answer: z
    .string()
    .describe('The word or phrase that correctly fills the blank.'),
});

// Remove 'export' from the schema constant
const GeneratedQuestionSchema = z.discriminatedUnion('type', [
  OpenEndedQuestionSchema,
  MultipleChoiceQuestionSchema,
  FillInTheBlankQuestionSchema,
]);
export type GeneratedQuestion = z.infer<typeof GeneratedQuestionSchema>;

const GenerateDynamicQuestsOutputSchema = z.object({
  questions: z
    .array(GeneratedQuestionSchema)
    .describe(
      'An array of dynamically generated questions of the specified type.'
    ),
});

export type GenerateDynamicQuestsOutput = z.infer<
  typeof GenerateDynamicQuestsOutputSchema
>;

export async function generateDynamicQuests(
  input: GenerateDynamicQuestsInput
): Promise<GenerateDynamicQuestsOutput> {
  return generateDynamicQuestsFlow(input);
}

const generateDynamicQuestsPrompt = ai.definePrompt({
  name: 'generateDynamicQuestsPrompt',
  input: {schema: GenerateDynamicQuestsInputSchema},
  output: {schema: GenerateDynamicQuestsOutputSchema},
  prompt: `You are an AI-powered educational tool that generates dynamic questions tailored to student learning history and the desired question type.

  Based on the student's learning history: {{{studentLearningHistory}}}, generate {{{numberOfQuestions}}} questions on the topic of {{{topic}}} with a difficulty level of {{{difficultyLevel}}}.
  The type of questions to generate is: {{{questionType}}}.

  Ensure the questions are relevant, engaging, and address the student's specific needs and weaknesses.
  The output must be a JSON object with a "questions" array, where each element in the array is an object corresponding to the specified 'questionType'.

  If 'questionType' is 'open-ended', each question object in the "questions" array should be:
  { "type": "open-ended", "question": "The open-ended question text." }
  Example: { "questions": [{ "type": "open-ended", "question": "What is photosynthesis?" }] }

  If 'questionType' is 'multiple-choice', each question object in the "questions" array should be:
  { "type": "multiple-choice", "question": "The question text.", "options": ["Option A", "Option B", "Option C", "Option D"], "correctAnswer": "Option C" }
  Ensure 'correctAnswer' exactly matches one of the strings in the 'options' array. Provide 3 or 4 options.
  Example: { "questions": [{ "type": "multiple-choice", "question": "What is the capital of France?", "options": ["London", "Paris", "Berlin"], "correctAnswer": "Paris" }] }

  If 'questionType' is 'fill-in-the-blank', each question object in the "questions" array should be:
  { "type": "fill-in-the-blank", "questionWithBlank": "The question text with '___' as the placeholder.", "answer": "The correct answer for the blank." }
  Example: { "questions": [{ "type": "fill-in-the-blank", "questionWithBlank": "The sun rises in the ___.", "answer": "East" }] }
  `,
});

const generateDynamicQuestsFlow = ai.defineFlow(
  {
    name: 'generateDynamicQuestsFlow',
    inputSchema: GenerateDynamicQuestsInputSchema,
    outputSchema: GenerateDynamicQuestsOutputSchema,
  },
  async input => {
    const {output} = await generateDynamicQuestsPrompt(input);
    // Ensure output is not null and has a questions property
    if (!output || !output.questions) {
        // This case should ideally be handled by Zod schema validation if the LLM returns an unexpected structure.
        // If the LLM fails to return a valid JSON or the structure is wrong, an error would likely be thrown before this point.
        console.error("generateDynamicQuestsFlow: LLM output was null or missing questions property", output);
        return { questions: [] };
    }
    return output;
  }
);

